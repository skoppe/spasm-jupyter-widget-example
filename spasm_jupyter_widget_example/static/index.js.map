{"version":3,"sources":["webpack:///webpack/bootstrap 64c14706f135dfbb108b","webpack:///./lib/spasm.js","webpack:///./lib/index.js","webpack:///./lib/example.js","webpack:///external \"@jupyter-widgets/base\"","webpack:///./lib/spa.js","webpack:///./node_modules/process/browser.js","webpack:///./package.json"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,KAAK;QACL;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gJAAgJ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAE8C;;;;;;;ACpI9C;AACA,iBAAiB,mBAAO,CAAC,CAAc;AACvC,4BAA4B,mBAAO,CAAC,CAAiB;;;;;;;;ACFrD;AAAA;AAAA;AAAA,cAAc,mBAAO,CAAC,CAAuB;AACJ;AACV;;AAE/B,cAAc,gDAAiB;;AAExB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAE;AAAA;AAAA;;AAEH;AACA;AACA;AACA,0CAA0C,mDAAoB;AAC9D,SAAS;AACT;AACA,mCAAmC,mDAAoB;AACvD,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,kCAAkC,mDAAoB;AACtD;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB,0DAAa;AACjC;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B;AACA,CAAC,EAAE;AAAA;AAAA;;;;;;;ACpDH,+C;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AACkF;;AAElF,YAAY,gDAAG;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;AAClB;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,mDAAO;AACrC;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mDAAO;AAC7C,SAAS;AACT;AACA,yCAAyC,mDAAO;AAChD,SAAS;AACT;AACA;AACA,0CAA0C,mDAAO;AACjD;AACA,6CAA6C,mDAAO;AACpD,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,uCAAuC,mDAAO;AAC9C,SAAS;AACT;AACA,yBAAyB,mDAAO;AAChC;AACA,SAAS;AACT;AACA,yBAAyB,mDAAO;AAChC,0BAA0B,mDAAO;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE,aAAa;AACb,+CAA+C,MAAM,mBAAmB;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,mDAAO;AACzC,SAAS;AACT;AACA,kCAAkC,mDAAO;AACzC,SAAS;AACT;AACA,mBAAmB,mDAAO,gCAAgC,mDAAO;AACjE,SAAS;AACT;AACA;AACA,yBAAyB,mDAAO;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,mDAAO;AAChC;AACA,6BAA6B,mDAAO;AACpC;AACA,SAAS;AACT;AACA;AACA,yBAAyB,mDAAO;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,mDAAO;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,mDAAO;AAChC;AACA,uBAAuB,mDAAO;AAC9B,mBAAmB,mDAAO;AAC1B,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAO;AAC/B;AACA;AACA,gBAAgB,mDAAO;AACvB;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;ACzLA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC,kBAAkB,wKAAwK,gFAAgF,+HAA+H,kKAAkK,oBAAoB,qCAAqC,iBAAiB,qCAAqC,eAAe,6B","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 64c14706f135dfbb108b","// File is autogenerated with `dub run spasm:bootstrap-webpack`\nconst abort = (what,file,line) => {\n    throw `ABORT: $what @ $file:$line`;\n}\n\nconst utf8Decoder = new TextDecoder('utf-8');\nconst utf8Encoder = new TextEncoder();\n\nlet objects = {1: document, 2: window};\nlet freelist = [];\nlet addObject = (value) => {\n        if (value === null || value == undefined) return 0;\n        let idx = freelist.pop() || ++spasm.lastPtr;\n        objects[idx] = value;\n        return idx;\n    },\n    getObject = (ptr) => objects[ptr];\nconst setupMemory = (memory) => {\n    spasm.memory = memory;\n    spasm.buffer = memory.buffer;\n}\nconst baseUrl = document.querySelector('body').getAttribute('data-base-url') + 'nbextensions/spasm_jupyter_widget_example';\n\nconst spasm = {\n    lastPtr: 2,\n    instance: null,\n    init: (modules) => {\n        window.spasm = spasm\n        console.log(modules)\n        if (!spasm.exports) {\n            var tmp = {};\n            modules.map(m=>m.jsExports).filter(a=>!!a).map(e=>Object.entries(e).forEach(e=>tmp[e[0]] = Object.assign.apply(null,[tmp[e[0]] || {}, e[1]])));\n            spasm.exports = tmp;\n        }\n        return fetch(baseUrl+'/spasm_jupyter_widget_example.wasm')\n            .then(request => request.arrayBuffer())\n            // .then(bytes => WebAssembly.compile(bytes))\n            .then(module => new WebAssembly.instantiate(module, spasm.exports))\n            .then(result => result.instance)\n            .then(instance => {\n                console.log(instance)\n                spasm.instance = instance\n                setupMemory(instance.exports.memory);\n                instance.exports._start(instance.exports.__heap_base);\n            });\n    },\n    objects,\n    addObject: addObject,\n}\n\nlet encoders = {\n    string: (ptr, val) => {\n        const encodedString = utf8Encoder.encode(val);\n        const wasmPtr = spasm.instance.exports.allocString(encodedString.length);\n        const asBytes = new Uint8Array(spasm.memory.buffer, wasmPtr, encodedString.length);\n        const heapi32u = new Uint32Array(spasm.memory.buffer)\n        heapi32u[ptr / 4] = encodedString.length;\n        heapi32u[(ptr / 4)+1] = wasmPtr;\n        asBytes.set(encodedString);\n        return ptr;\n    }\n}\nlet decoders = {\n    string: (len, offset) => {\n        if (offset == null) {\n            const heapi32u = new Uint32Array(spasm.memory.buffer)\n            offset = heapi32u[(len+4)/4];\n            len = heapi32u[(len/4)];\n        }\n        return utf8Decoder.decode(new DataView(spasm.memory.buffer,offset,len));\n    }\n}\nlet jsExports = {\n    env: {\n        onOutOfMemoryError: () => abort(\"Out of memory exception\"),\n        _d_assert: (file,line) => abort(\"assert\",file,line),\n        doLog: arg => console.log(arg),\n        memory: spasm.memory,\n        __assert: () => {},\n        _Unwind_Resume: () => {\n            console.log(arguments);\n        },\n        _d_dynamic_cast: () => {\n            console.log(arguments)\n        },\n        spasm_add__bool: (b)=>addObject(!!b),\n        spasm_add__int: addObject,\n        spasm_add__uint: addObject,\n        spasm_add__long: addObject,\n        spasm_add__ulong: addObject,\n        spasm_add__short: addObject,\n        spasm_add__ushort: addObject,\n        spasm_add__byte: addObject,\n        spasm_add__ubyte: addObject,\n        spasm_add__float: addObject,\n        spasm_add__double: addObject,\n        spasm_add__object: () => addObject({}),\n        spasm_add__string: (len, offset) => {\n            return addObject(decoders.string(len, offset));\n        },\n        spasm_get__field: (handle, len, offset) => {\n            return addObject(getObject(handle)[decoders.string(len,offset)]);\n        },\n        spasm_get__int: getObject,\n        spasm_get__uint: getObject,\n        spasm_get__long: getObject,\n        spasm_get__ulong: getObject,\n        spasm_get__short: getObject,\n        spasm_get__ushort: getObject,\n        spasm_get__float: getObject,\n        spasm_get__double: getObject,\n        spasm_get__byte: getObject,\n        spasm_get__ubyte: getObject,\n        spasm_get__string: (rawResult, ptr) => {\n            encoders.string(rawResult, getObject(ptr));\n        },\n        spasm_removeObject: (ctx) => {\n            freelist.push(ctx)\n            delete objects[ctx]\n        },\n        DataView_Create: (len, offset) => {\n            return addObject(new DataView(spasm.memory.buffer, offset, len));\n        },\n        Float32Array_Create: (len, offset) => {\n            return addObject(new Float32Array(spasm.memory.buffer, offset, len));\n        },\n        Uint8Array_Create: (len, offset) => {\n            return addObject(new Uint8Array(spasm.memory.buffer, offset, len));\n        }\n    }\n};\n\nexport {spasm, encoders, decoders, jsExports};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/spasm.js\n// module id = 0\n// module chunks = 0","// Export widget models and views, and the npm package version number.\nmodule.exports = require('./example.js');\nmodule.exports['version'] = require('../package.json').version;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/index.js\n// module id = 1\n// module chunks = 0","var widgets = require('@jupyter-widgets/base');\nimport * as spasmModule from './spasm.js'\nimport * as spa from './spa.js'\n\nconst spasm = spasmModule.spasm;\n\nexport const HelloModel = widgets.DOMWidgetModel.extend({\n    defaults: _.extend(widgets.DOMWidgetModel.prototype.defaults(), {\n        _model_name : 'HelloModel',\n        _view_name : 'HelloView',\n        _model_module : 'spasm_jupyter_widget_example',\n        _view_module : 'spasm_jupyter_widget_example',\n        _model_module_version : '0.1.0',\n        _view_module_version : '0.1.0',\n        value: 3\n    })\n});\n\nconst modelExports = {\n    env: {\n        getModelInt: (ptr, len, off) => {\n            return spasm.objects[ptr].get(spasmModule.decoders.string(len,off));\n        },\n        setModelInt: (ptr, len, off, value) => {\n            spasm.objects[ptr].set(spasmModule.decoders.string(len, off), value);\n        },\n        saveChanges: (ptr) => {\n            spasm.objects[ptr].save_changes();\n        },\n        onModelChange: (ptr, len, off, cbCtx, cbPtr) => {\n            spasm.objects[ptr].on(spasmModule.decoders.string(len,off), ()=>spasm.instance.exports.__indirect_function_table.get(cbPtr)(cbCtx));\n        }\n    }\n}\n\nexport const HelloView = widgets.DOMWidgetView.extend({\n    render: function() {\n        // NOTE: spasm by default comes with a getRoot function that behaves as a singleton\n        // we have to override it to ensure spasm renders itself inside this widget's dom element\n        const customGetRoot = () => spasm.addObject(this.el);\n        const patchedSpaModule = {\n            jsExports: {\n                env: Object.assign(\n                    {},\n                    spa.jsExports.env,\n                    modelExports.env,\n                    {getRoot: customGetRoot, getModel: () => spasm.addObject(this.model)}\n                )\n            }\n        };\n        spasm.init([spasmModule,patchedSpaModule])\n    }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/example.js\n// module id = 2\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@jupyter-widgets/base\"\n// module id = 3\n// module chunks = 0","// File is autogenerated with `dub run spasm:bootstrap-webpack`\nimport {spasm as spa, decoders as decoder, encoders as encoder} from './spasm.js';\n\nlet spasm = spa;\nconst nodes = spasm.objects;\n\nconst addPtr = spasm.addObject;\nlet tags = [\"a\",\"abbr\",\"address\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"bdi\",\"bdo\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"cite\",\"code\",\"col\",\"colgroup\",\"data\",\"datalist\",\"dd\",\"del\",\"dfn\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"main\",\"map\",\"mark\",\"meta\",\"meter\",\"nav\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"pre\",\"progress\",\"q\",\"rb\",\"rp\",\"rt\",\"rtc\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"small\",\"source\",\"span\",\"strong\",\"style\",\"sub\",\"sup\",\"table\",\"tbody\",\"td\",\"template\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"];\nconst getTagFromType = (type) => {\n    return tags[type];\n}\n\nlet events = ['click','change','input','keydown','keyup','dblclick','blur','mousemove','mouseup','mousedown','keypress'];\n\nlet currentEvent= null;\n\nconst eventHandler = (event) => {\n    const id = event.currentTarget.wasmId;\n    const handlers = event.currentTarget.wasmEvents[event.type];\n    const cbs = handlers.cbs;\n    currentEvent = event;\n    cbs.forEach(cb=>spasm.instance.exports.domEvent(id, cb.ctx, cb.fun, handlers.eventType));\n    currentEvent = null;\n}\n\nexport { nodes, addPtr };\nexport let jsExports = {\n    env: {\n        appendChild: (parent, child) => {\n            nodes[parent].appendChild(nodes[child]);\n        },\n        insertBefore: (parent, child, sibling) => {\n            nodes[parent].insertBefore(nodes[child], nodes[sibling]);\n        },\n        addCss: (cssLen, cssOffset) => {\n            var style = document.createElement('style');\n            style.type = 'text/css';\n            style.innerHTML = decoder.string(cssLen, cssOffset);\n            document.getElementsByTagName('head')[0].appendChild(style);\n            addPtr(style);\n        },\n        addClass: (node, classLen, classOffset) => {\n            nodes[node].classList.add(decoder.string(classLen, classOffset));\n        },\n        removeClass: (node, classLen, classOffset) => {\n            nodes[node].classList.remove(decoder.string(classLen, classOffset));\n        },\n        changeClass: (node, classLen, classOffset, on) => {\n            if (on)\n                nodes[node].classList.add(decoder.string(classLen, classOffset));\n            else\n                nodes[node].classList.remove(decoder.string(classLen, classOffset));\n        },\n        unmount: (childPtr) => {\n            var child = nodes[childPtr];\n            child.parentNode.removeChild(child);\n        },\n        removeChild: (childPtr) => {\n            var child = nodes[childPtr];\n            child.parentNode.removeChild(child);\n            // TODO: we can reuse the child node (it is cheaper than recreating a new one...)\n        },\n        getRoot: () => {\n            return addPtr(document.querySelector(\"#root\"));\n        },\n        createElement: (type) => {\n            return addPtr(document.createElement(getTagFromType(type)));\n        },\n        setSelectionRange: (nodePtr, start, end) => {\n            nodes[nodePtr].setSelectionRange(start, end);\n        },\n        innerText: (nodePtr,textLen, textOffset) => {\n            nodes[nodePtr].innerText = decoder.string(textLen,textOffset);\n        },\n        setAttributeInt: (node, attrLen, attrOffset, value) => {\n            const attr = decoder.string(attrLen,attrOffset);\n            nodes[node].setAttribute(attr, value);\n        },\n        setAttribute: (node, attrLen, attrOffset, valueLen, valueOffset) => {\n            const attr = decoder.string(attrLen,attrOffset);\n            const value = decoder.string(valueLen,valueOffset);\n            nodes[node].setAttribute(attr, value);\n        },\n        addEventListener: (nodePtr, listenerType, ctx, fun, eventType) => {\n            var listenerTypeStr = events[listenerType];\n            var node = nodes[nodePtr];\n            if (node.wasmEvents === undefined)\n                var nodeEvents = node.wasmEvents = {};\n            else\n                var nodeEvents = nodes[nodePtr].wasmEvents;\n            if (nodeEvents[listenerTypeStr] && nodeEvents[listenerTypeStr].cbs.length > 0) {\n                nodeEvents[listenerTypeStr].cbs.push({ctx:ctx,fun:fun});\n            } else {\n                nodeEvents[listenerTypeStr] = {cbs:[{ctx: ctx, fun: fun}], eventType: eventType};\n                node.addEventListener(listenerTypeStr, eventHandler);\n            }\n        },\n        removeEventListener: (nodePtr, listenerType, ctx, fun, eventType) => {\n            var listenerTypeStr = events[listenerType];\n            var node = nodes[nodePtr];\n            if (node.wasmEvents === undefined)\n                return;\n            var nodeEvents = nodes[nodePtr].wasmEvents;\n            if (nodeEvents[listenerTypeStr] && nodeEvents[listenerTypeStr].cbs.length > 0) {\n                nodeEvents[listenerTypeStr].cbs = nodeEvents[listenerTypeStr].cbs.filter(cb=>!(cb.ctx==ctx && cb.fun==fun));\n            }\n        },\n        getEventBool: (propLen, propOffset) => {\n            return !!currentEvent[decoder.string(propLen,propOffset)];\n        },\n        getEventInt: (propLen,propOffset) => {\n            return 0+currentEvent[decoder.string(propLen,propOffset)];\n        },\n        getEventString: (resultRaw, propLen,propOffset) => {\n            return encoder.string(resultRaw, currentEvent[decoder.string(propLen,propOffset)]);\n        },\n        setPropertyBool: (nodePtr, propLen, propOffset, value) => {\n            const node = nodes[nodePtr];\n            const prop = decoder.string(propLen, propOffset);\n            if (node && node[prop] !== undefined)\n                node[prop] = value;\n        },\n        setPropertyInt: (nodePtr, propLen, propOffset, value) => {\n            jsExports.env.setPropertyBool(nodePtr, propLen, propOffset, value);\n        },\n        setProperty: (nodePtr, propLen, propOffset, valueLen, valueOffset) => {\n            const node = nodes[nodePtr];\n            const prop = decoder.string(propLen, propOffset);\n            if (node && node[prop] !== undefined) {\n                node[prop] = decoder.string(valueLen, valueOffset);\n            }\n        },\n        getPropertyInt: (nodePtr, propLen, propOffset) => {\n            const node = nodes[nodePtr];\n            const prop = decoder.string(propLen, propOffset);\n            if (!node || node[prop] === undefined)\n                return false;\n            return +node[prop];\n        },\n        getPropertyBool: (nodePtr, propLen, propOffset) => {\n            const node = nodes[nodePtr];\n            const prop = decoder.string(propLen, propOffset);\n            if (!node || node[prop] === undefined)\n                return false;\n            return !!node[prop];\n        },\n        getProperty: (resultRaw, nodePtr, propLen, propOffset) => {\n            const node = nodes[nodePtr];\n            const prop = decoder.string(propLen, propOffset);\n            if (!node || node[prop] === undefined)\n                return encoder.string(resultRaw,\"\");\n            return encoder.string(resultRaw,node[prop]);\n        },\n    }\n}\n\nif (process.env.NODE_ENV === 'development') {\n    function reload() {\n        const root = document.querySelector(\"#root\");\n        // TODO: how do we handle outstanding setTimeout or other schedule functions?\n        // For now we assume the same callbacks will be available in the reloaded module\n        // but that may not be the case.\n        for(var i = spasm.lastPtr; i > 3; i--) {\n            if (spasm.objects[i].remove)\n                spasm.objects[i].remove();\n            delete spasm.objects[i];\n        }\n        spasm.lastPtr = 2;\n        spasm.init();\n    }\n    const ws = new WebSocket('ws://localhost:3001');\n    ws.onmessage = function(event) {\n        if (event.data === 'reload') {\n            if (!spasm.instance.exports.dumpApp || !spasm.instance.exports.loadApp)\n                return;\n            spasm.instance.exports.dumpApp(0);\n            var state = decoder.string(0);\n            reload();\n            setTimeout(()=>{\n                encoder.string(0, state);\n                const heapi32u = new Uint32Array(spasm.memory.buffer)\n                spasm.instance.exports.loadApp(heapi32u[0], heapi32u[1]);\n            }, 1);\n        }\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/spa.js\n// module id = 4\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 5\n// module chunks = 0","module.exports = {\"name\":\"spasm_jupyter_widget_example\",\"version\":\"0.1.0\",\"description\":\"A Custom Jupyter Widget Library\",\"author\":\"Sebastiaan Koppe\",\"main\":\"lib/index.js\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/skoppe/spasm_jupyter_widget_example.git\"},\"keywords\":[\"jupyter\",\"widgets\",\"ipython\",\"ipywidgets\",\"jupyterlab-extension\"],\"files\":[\"lib/**/*.js\",\"dist/*.js\"],\"scripts\":{\"clean\":\"rimraf dist/\",\"prepublish\":\"webpack\",\"build\":\"webpack\",\"watch\":\"webpack --watch --mode=development\",\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"devDependencies\":{\"webpack\":\"^3.5.5\",\"rimraf\":\"^2.6.1\"},\"dependencies\":{\"@jupyter-widgets/base\":\"^1.1 || ^2\"},\"jupyterlab\":{\"extension\":\"lib/labplugin\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./package.json\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}